use genai::{
    ModelIden,
    chat::{ChatRole, ContentPart, MessageContent, MessageOptions, ToolCall, Usage},
};
use serde::{Deserialize, Serialize};

use crate::{MessageId, RequestId};

/// A message to be processed by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub id: MessageId,
    pub role: ChatRole,
    pub content: MessageContent,
    pub metadata: MessageMetadata,
    pub options: Option<MessageOptions>,
}

/// Metadata associated with a message
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct MessageMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guild_id: Option<String>,
    #[serde(flatten)]
    pub custom: serde_json::Value,
}

/// A response generated by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
    pub id: RequestId,
    pub system: Option<Vec<String>>,
    pub tools: Option<Vec<genai::chat::Tool>>,
}

/// A response generated by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    pub id: MessageId,
    pub content: Option<MessageContent>,
    pub reasoning: Option<String>,
    pub tool_calls: Vec<ToolCall>,
    pub metadata: ResponseMetadata,
}

/// Metadata for a response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub processing_time: Option<chrono::Duration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tokens_used: Option<Usage>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model_used: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f32>,
    pub model_iden: ModelIden,
    pub custom: serde_json::Value,
}

impl Message {
    pub fn user(content: impl Into<MessageContent>) -> Self {
        Self {
            id: MessageId::generate(),
            role: ChatRole::User,
            content: content.into(),
            metadata: MessageMetadata::default(),
            options: None,
        }
    }

    pub fn system(content: impl Into<MessageContent>) -> Self {
        Self {
            id: MessageId::generate(),
            role: ChatRole::System,
            content: content.into(),
            metadata: MessageMetadata::default(),
            options: None,
        }
    }

    pub fn agent(content: impl Into<MessageContent>) -> Self {
        Self {
            id: MessageId::generate(),
            role: ChatRole::Assistant,
            content: content.into(),
            metadata: MessageMetadata::default(),
            options: None,
        }
    }

    pub fn text_content(&self) -> Option<String> {
        match &self.content {
            MessageContent::Text(text) => Some(text.clone()),
            MessageContent::Parts(parts) => {
                // Concatenate all text parts
                let text_parts: Vec<String> = parts
                    .iter()
                    .filter_map(|part| match part {
                        ContentPart::Text(text) => Some(text.clone()),
                        _ => None,
                    })
                    .collect();

                if text_parts.is_empty() {
                    None
                } else {
                    Some(text_parts.join(" "))
                }
            }
            _ => None,
        }
    }

    pub fn has_tool_calls(&self) -> bool {
        matches!(&self.content, MessageContent::ToolCalls(_))
    }

    pub fn tool_call_count(&self) -> usize {
        match &self.content {
            MessageContent::ToolCalls(calls) => calls.len(),
            _ => 0,
        }
    }

    pub fn estimate_tokens(&self) -> usize {
        // Rough estimation: ~4 chars per token
        match &self.content {
            MessageContent::Text(text) => (text.len() as f32 / 4.0) as usize,
            MessageContent::Parts(parts) => {
                parts
                    .iter()
                    .map(|part| match part {
                        ContentPart::Text(text) => (text.len() as f32 / 4.0) as usize,
                        _ => 25, // Rough estimate for non-text content
                    })
                    .sum()
            }
            MessageContent::ToolCalls(calls) => calls.len() * 50, // Rough estimate
            MessageContent::ToolResponses(responses) => responses.len() * 30, // Rough estimate
        }
    }
}
