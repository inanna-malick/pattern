use genai::{
    ModelIden,
    chat::{ChatRole, ContentPart, MessageContent, MessageOptions, ToolCall, Usage},
};
use serde::{Deserialize, Serialize};
use serde_json::json;

use crate::MessageId;

/// A message to be processed by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub id: MessageId,
    pub role: ChatRole,
    pub content: MessageContent,
    pub metadata: MessageMetadata,
    pub options: Option<MessageOptions>,
}

impl Message {
    pub fn as_chat_message(&self) -> genai::chat::ChatMessage {
        genai::chat::ChatMessage {
            role: self.role.clone(),
            content: self.content.clone(),
            options: self.options.clone(),
        }
    }
}

/// Metadata associated with a message
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct MessageMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guild_id: Option<String>,
    #[serde(flatten)]
    pub custom: serde_json::Value,
}

/// A response generated by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
    pub system: Option<Vec<String>>,
    pub messages: Vec<Message>,
    pub tools: Option<Vec<genai::chat::Tool>>,
}

impl Request {
    pub fn as_chat_request(&self) -> genai::chat::ChatRequest {
        genai::chat::ChatRequest::from_system(self.system.clone().unwrap().join("\n\n"))
            .append_messages(self.messages.iter().map(Message::as_chat_message).collect())
            .with_tools(self.tools.clone().unwrap_or_default())
    }
}

/// A response generated by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    pub content: Vec<MessageContent>,
    pub reasoning: Option<String>,
    pub tool_calls: Vec<ToolCall>,
    pub metadata: ResponseMetadata,
}

impl Response {
    pub fn from_chat_response(resp: genai::chat::ChatResponse) -> Self {
        let metadata = ResponseMetadata {
            processing_time: None,
            tokens_used: Some(resp.usage.clone()),
            model_used: Some(resp.provider_model_iden.to_string()),
            confidence: None,
            model_iden: resp.model_iden.clone(),
            custom: resp.captured_raw_body.clone().unwrap_or_default(),
        };
        Self {
            content: resp.content.clone(),
            reasoning: resp.reasoning_content.clone(),
            tool_calls: resp.into_tool_calls(),
            metadata,
        }
    }
}

/// Metadata for a response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub processing_time: Option<chrono::Duration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tokens_used: Option<Usage>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model_used: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f32>,
    pub model_iden: ModelIden,
    pub custom: serde_json::Value,
}

impl Default for ResponseMetadata {
    fn default() -> Self {
        Self {
            processing_time: None,
            tokens_used: None,
            model_used: None,
            confidence: None,
            custom: json!({}),
            model_iden: ModelIden::new(genai::adapter::AdapterKind::Ollama, "default_model"),
        }
    }
}

impl Message {
    pub fn user(content: impl Into<MessageContent>) -> Self {
        Self {
            id: MessageId::generate(),
            role: ChatRole::User,
            content: content.into(),
            metadata: MessageMetadata::default(),
            options: None,
        }
    }

    pub fn system(content: impl Into<MessageContent>) -> Self {
        Self {
            id: MessageId::generate(),
            role: ChatRole::System,
            content: content.into(),
            metadata: MessageMetadata::default(),
            options: None,
        }
    }

    pub fn agent(content: impl Into<MessageContent>) -> Self {
        Self {
            id: MessageId::generate(),
            role: ChatRole::Assistant,
            content: content.into(),
            metadata: MessageMetadata::default(),
            options: None,
        }
    }

    pub fn text_content(&self) -> Option<String> {
        match &self.content {
            MessageContent::Text(text) => Some(text.clone()),
            MessageContent::Parts(parts) => {
                // Concatenate all text parts
                let text_parts: Vec<String> = parts
                    .iter()
                    .filter_map(|part| match part {
                        ContentPart::Text(text) => Some(text.clone()),
                        _ => None,
                    })
                    .collect();

                if text_parts.is_empty() {
                    None
                } else {
                    Some(text_parts.join(" "))
                }
            }
            _ => None,
        }
    }

    pub fn has_tool_calls(&self) -> bool {
        matches!(&self.content, MessageContent::ToolCalls(_))
    }

    pub fn tool_call_count(&self) -> usize {
        match &self.content {
            MessageContent::ToolCalls(calls) => calls.len(),
            _ => 0,
        }
    }

    pub fn estimate_tokens(&self) -> usize {
        // Rough estimation: ~4 chars per token
        match &self.content {
            MessageContent::Text(text) => (text.len() as f32 / 4.0) as usize,
            MessageContent::Parts(parts) => {
                parts
                    .iter()
                    .map(|part| match part {
                        ContentPart::Text(text) => (text.len() as f32 / 4.0) as usize,
                        _ => 25, // Rough estimate for non-text content
                    })
                    .sum()
            }
            MessageContent::ToolCalls(calls) => calls.len() * 50, // Rough estimate
            MessageContent::ToolResponses(responses) => responses.len() * 30, // Rough estimate
        }
    }
}
